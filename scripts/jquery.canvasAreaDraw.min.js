//TODO: fazer com que cada toque ele verifique se é um forma dentro do array shapes, se for então ele só vai deixar destacado ou com a possibilidade de editar // dificil
//fechar o quadrado quando clicar no primeiro ponto ou enter // facil
//criar o SVG // Muito dificil eu acho**
(function ($) {
    $.fn.canvasAreaDraw = function (options) {

        this.each(function (index, element) {
            init.apply(element, [index, element, options]);
        });

    }

    var init = function (index, input, options) {
        var points, activePoint, settings, shapes, activeShape, titles;
        var $reset, $canvas,$svg,$save, ctx, image;
        var draw, mousedown, stopdrag, move, moveall, resize, reset, rightclick, record, save;
        var dragpoint;
        var startpoint = false;
        var imageurl, inputtitle;
        divcanvas = document.createElement("div");
        settings = $.extend({
            imageUrl: imageurl
        }, options);
        var addShape = function() {
            shapes.push([]);
            activeShape = shapes.length - 1;
            points = shapes[activeShape]
            ctx.moveTo(shapes[activeShape][0],shapes[activeShape][1]);
            titles.push(activeShape+1)
            $("#shapes").append("<div id ='shape"+activeShape+"' class='ms-5 mb-3'><p>"+(activeShape+1)+"</p><input placeholder='name' type='text' class='title-input d-block mb-2 w-100'><textarea class='w-100'></textarea></div>")
            inputtitle = document.getElementsByClassName("title-input");
            $(document).find(inputtitle).on("change", function(e){
                var indexA = e.target.parentNode.id.slice(5)
                titles[indexA] = e.target.value
                console.log(titles)
                draw();
            })
        };
        titles = []
        shapes = [];
        points = shapes[activeShape]

        // var v = $(input).val().replace(/[^0-9\,]/ig, '');
        // if (v.length) {
        //      points = [];// v.split(',') .map(function (point) {
        //     //     console.log(parseInt(point,10))
        //     //     //return parseInt(point, 10);
        //     // });
        // } else {
        //     points = [];
        // }
        
        $reset = $('<button type="button" class="btn"><i class="icon-trash"></i>Clear All</button>');
        $removeImg = $('<button type="button" class="btn btn-danger"><i class="icon-trash"></i>Remove Image</button>')
        $save = $('<a  class="btn btn-success" download>Save</a>')
        $instrucoes = $('<p>Aperte "V" para fechar um polígono!</p> <p>Não esqueça de nomear os polígonos à direita!</p> <p>Aperta com o botão direito do mouse em cima de um ponto para apagá-lo</p>')
        $canvas = $('<canvas>');
        ctx = $canvas[0].getContext('2d');
        trackTransforms(ctx);

        image = new Image();
        resize = function () {
            redraw();
            $canvas.attr('height', image.height).attr('width', window.innerWidth /2);
            draw();
        };
        function redraw(){
            // var p1 = ctx.transformedPoint(0,0);
            // var p2 = ctx.transformedPoint($canvas.width,$canvas.height);
            // ctx.clearRect(p1.x,p1.y,p2.x-p1.x,p2.y-p1.y);

            ctx.save();
            ctx.setTransform(1,0,0,1,0,0);
            ctx.clearRect(0,0,$canvas.width,$canvas.height);
            ctx.restore();

            ctx.drawImage(image,0,0);
        }
       
        window.addEventListener("keydown", function(e){
            if(e.key == "v"){
                if(shapes.length > 0){
                    if(points.length >= 6){
                        addShape();
                    }
                }
            }
        })
        $(image).load(resize);
        image.src = settings.imageUrl;
        if (image.loaded) {
            resize();
        }
        $canvas.css({border:'1px solid #ccc'});
        divcanvas.classList.add("d-flex")
        var divshapes = document.createElement("div")
        divshapes.classList.add("col-5")
        divshapes.classList.add("overflow-y-scroll")
        divshapes.classList.add("my-auto")
        console.log(image.height)
        divshapes.style.height = `500px`
        divshapes.id = "shapes"
        divcanvas.append($canvas[0])
        divcanvas.append(divshapes)

        $(input).after($instrucoes,'<br>', divcanvas, '<br>', $reset, $removeImg,$save);

        save = function(){
            var svg = ''
            svg = '<svg id="Map" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 ' + image.width + ' ' + image.height + '" xml:space="preserve"><image width="' + image.width + '" height="' + image.height + '" xlink:href="' + image.src + '" />';
			
			for (var s = 0; s < shapes.length; s++) {
				var title = titles[s]
				
				var points = shapes[s].join(',');
				svg += '<polygon  title="' + title + '" points="' + points + '" />';
			}
			
			svg += '</svg>';
            

            $svg = $(svg)
            console.log($svg)
            var serializer = new XMLSerializer();
            var source = serializer.serializeToString($svg[0]);

            if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
                source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
            }
            if(!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)){
                source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
            }

            source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
            var url = "data:image/svg+xml;charset=utf-8,"+encodeURIComponent(source);

            $save[0].href = url
        }

        reset = function () {
            points = [];
            shapes = [];
            titles = [];
            while(divshapes.firstChild){
                divshapes.removeChild(divshapes.lastChild);
            }
            draw();
        };

        removeImg = function () {
            reset();
            const arrE = Array.from(editor.children)
            console.log(arrE)
            arrE.forEach((element) => {
                if(element.tagName != "INPUT"){
                    editor.removeChild(element)   
                }
            })
            $("#uploader").removeClass("d-none")
        };

        move = function (e) {
            if (!e.offsetX) {
                e.offsetX = (e.pageX - $(e.target).offset().left);
                e.offsetY = (e.pageY - $(e.target).offset().top);
            }
            $("#shape"+activeShape).children()[2].innerHTML = "";
            points[activePoint] = Math.round(e.offsetX);
            points[activePoint + 1] = Math.round(e.offsetY);
            points.forEach(value =>{
                $("#shape"+activeShape).children()[2].append(value+", ")
            })
            draw();
        };

        moveall = function (e) {
            if (!e.offsetX) {
                e.offsetX = (e.pageX - $(e.target).offset().left);
                e.offsetY = (e.pageY - $(e.target).offset().top);
            }
            if (!startpoint) {
                startpoint = {x: Math.round(e.offsetX), y: Math.round(e.offsetY)};
            }
            var sdvpoint = {x: Math.round(e.offsetX), y: Math.round(e.offsetY)};
            for (var i = 0; i < points.length; i++) {
                points[i] = (sdvpoint.x - startpoint.x) + points[i];
                points[++i] = (sdvpoint.y - startpoint.y) + points[i];
            }
            startpoint = sdvpoint;
            draw();
        };

        stopdrag = function () {
            $(this).off('mousemove');
            record();
            activePoint = null;
        };

        rightclick = function (e) {
            e.preventDefault();
            if (!e.offsetX) {
                e.offsetX = (e.pageX - $(e.target).offset().left);
                e.offsetY = (e.pageY - $(e.target).offset().top);
            }
            var x = e.offsetX, y = e.offsetY;
            for (var i = 0; i < points.length; i += 2) {
                dis = Math.sqrt(Math.pow(x - points[i], 2) + Math.pow(y - points[i + 1], 2));
                if (dis < 6) {
                    points.splice(i, 2);
                    $("#shape"+activeShape).children()[2].innerHTML = ''
                    points.forEach(value =>{
                        $("#shape"+activeShape).children()[2].append(value+", ")
                    })
                    draw();
                    record();
                    return false;
                }
            }
            return false;
        };

        mousedown = function (e) { 
            var pt = ctx.transformedPoint(e.offsetX, e.offsetY);
            shapes.forEach((shape, index)=>{
                if(isPointInPoly(shape, pt)){
                    lastactive = activeShape;
                    activeShape = index;
                    points = shape;
                    return
                }
            })
            if(shapes.length <= 0){
                addShape();
            }else{
                minX = e.offsetX - 6;
                minY = e.offsetY - 6; 
                maxX = e.offsetX + 6; 
                maxY = e.offsetY + 6; 
                if(points[0] > minX && points[1] > minY && points[0] < maxX  && points[0] < maxY){
                    console.log("ta clicando")
                }
            }

            points = shapes[activeShape]
            var x, y, dis, lineDis, insertAt = points.length;
            if (e.which === 3) {
                return false;
            }

            
            
            e.preventDefault();
            if (!e.offsetX) {
                e.offsetX = (e.pageX - $(e.target).offset().left);
                e.offsetY = (e.pageY - $(e.target).offset().top);
            }
            x = e.offsetX;
            y = e.offsetY;
            
            $("#shape"+activeShape).children()[2].append(x+", "+y+", ")

            if (points.length >= 6) {
                var c = getCenter();
                ctx.fillRect(c.x - 4, c.y - 4, 8, 8);
                dis = Math.sqrt(Math.pow(x - c.x, 2) + Math.pow(y - c.y, 2));
                if (dis < 6) {
                    startpoint = false;
                    $(this).on('mousemove', moveall);
                    return false;
                }
            }

            for (var i = 0; i < points.length; i += 2) {
                dis = Math.sqrt(Math.pow(x - points[i], 2) + Math.pow(y - points[i + 1], 2));
                if (dis < 6) {
                    activePoint = i;
                    $(this).on('mousemove', move);
                    return false;
                }
            }

            for (var i = 0; i < points.length; i += 2) {
                if (i > 1) {
                    lineDis = dotLineLength(
                        x, y,
                        points[i], points[i + 1],
                        points[i - 2], points[i - 1],
                        true
                    );
                    if (lineDis < 6) {
                        insertAt = i;
                    }
                }
            }

            points.splice(insertAt, 0, Math.round(x), Math.round(y));
            activePoint = insertAt;
            $(this).on('mousemove', move);

            draw();
            record();

            return false;
        };


        draw = function () {
            ctx.canvas.width = ctx.canvas.width;
            record();

            if (shapes.length == 0) {
                redraw();

                return;
            }
            
            ctx.globalCompositeOperation = 'destination-over';
            ctx.fillStyle = 'rgb(255,255,255)';
            ctx.strokeStyle = 'rgb(0,0,255)';
            ctx.lineWidth = 1;
            shapes.forEach(points =>{
                if (points.length >= 6) {
                    var c = getCenter();
                    ctx.font = "20px Arial";
                    ctx.fillText(titles[activeShape], c.x, c.y);
                }
            })
            ctx.beginPath();
            //ctx.moveTo(points[0], points[1]);
            shapes.forEach(shape =>{
                for(var s = 0; s < shape.length; s += 2){
                    ctx.fillRect(shape[s] - 2, shape[s + 1] -2,4,4);
                    ctx.strokeRect(shape[s] - 2, shape[s + 1] -2,4,4);
                    if(s == 0){
                        ctx.moveTo(shape[s], shape[s+1]);
                    }else{
                        ctx.lineTo(shape[s], shape[s + 1]);
                    }
                }
                ctx.closePath();
            })
            // for (var i = 0; i < points.length; i += 2) {
            //     ctx.fillRect(points[i] - 2, points[i + 1] - 2, 4, 4);
            //     ctx.strokeRect(points[i] - 2, points[i + 1] - 2, 4, 4);
            //     if (points.length > 2 && i > 1) {
            //         ctx.lineTo(points[i], points[i + 1]);
            //     }
            // }
            ctx.fillStyle = 'rgba(0,0,255,0.3)';
            ctx.fill();
            ctx.stroke();
            redraw();
        };

        record = function () {
           $(input).val();
           console.log(points)
        };

        getCenter = function () {
            var ptc = [];
            for (i = 0; i < points.length; i++) {
                ptc.push({x: points[i], y: points[++i]});
            }
            var first = ptc[0], last = ptc[ptc.length - 1];
            if (first.x != last.x || first.y != last.y) ptc.push(first);
            var twicearea = 0,
                x = 0, y = 0,
                nptc = ptc.length,
                p1, p2, f;
            for (var i = 0, j = nptc - 1; i < nptc; j = i++) {
                p1 = ptc[i];
                p2 = ptc[j];
                f = p1.x * p2.y - p2.x * p1.y;
                twicearea += f;
                x += ( p1.x + p2.x ) * f;
                y += ( p1.y + p2.y ) * f;
            }
            f = twicearea * 3;
            return {x: x / f, y: y / f};
        };

        // $(input).on('change', function () {
        //     var v = $(input).val().replace(/[^0-9\,]/ig, '');
        //     if (v.length) {
        //         points = v.split(',').map(function (point) {
        //             return parseInt(point, 10);
        //         });
        //     } else {
        //         points = [];
        //     }
        //     draw();
        // });

        $(document).find($reset).click(reset);
        $(document).find($removeImg).click(removeImg);
        $(document).find($save).click(save);
        $(document).find($canvas).on('mousedown', mousedown);
        $(document).find($canvas).on('contextmenu', rightclick);
        $(document).find($canvas).on('mouseup', stopdrag);
    };

    // $(document).ready(function () {
    //     $('.canvas-area[data-image-url]').canvasAreaDraw();
    // });

    var dotLineLength = function (x, y, x0, y0, x1, y1, o) {
        function lineLength(x, y, x0, y0) {
            return Math.sqrt((x -= x0) * x + (y -= y0) * y);
        }

        if (o && !(o = function (x, y, x0, y0, x1, y1) {
                if (!(x1 - x0)) return {x: x0, y: y};
                else if (!(y1 - y0)) return {x: x, y: y0};
                var left, tg = -1 / ((y1 - y0) / (x1 - x0));
                return {
                    x: left = (x1 * (x * tg - y + y0) + x0 * (x * -tg + y - y1)) / (tg * (x1 - x0) + y0 - y1),
                    y: tg * left - tg * x + y
                };
            }(x, y, x0, y0, x1, y1), o.x >= Math.min(x0, x1) && o.x <= Math.max(x0, x1) && o.y >= Math.min(y0, y1) && o.y <= Math.max(y0, y1))) {
            var l1 = lineLength(x, y, x0, y0), l2 = lineLength(x, y, x1, y1);
            return l1 > l2 ? l2 : l1;
        }
        else {
            var a = y0 - y1, b = x1 - x0, c = x0 * y1 - y0 * x1;
            return Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);
        }
    };
})(jQuery);

function trackTransforms(ctx){
    var svg = document.createElementNS("http://www.w3.org/2000/svg",'svg');
    var xform = svg.createSVGMatrix();
    ctx.getTransform = function(){ return xform; };

    var savedTransforms = [];
    var save = ctx.save;
    ctx.save = function(){
        savedTransforms.push(xform.translate(0,0));
        return save.call(ctx);
    };
  
    var restore = ctx.restore;
    ctx.restore = function(){
      xform = savedTransforms.pop();
      return restore.call(ctx);
            };

    var scale = ctx.scale;
    ctx.scale = function(sx,sy){
      xform = xform.scaleNonUniform(sx,sy);
      return scale.call(ctx,sx,sy);
            };
  
    var rotate = ctx.rotate;
    ctx.rotate = function(radians){
        xform = xform.rotate(radians*180/Math.PI);
        return rotate.call(ctx,radians);
    };
  
    var translate = ctx.translate;
    ctx.translate = function(dx,dy){
        xform = xform.translate(dx,dy);
        return translate.call(ctx,dx,dy);
    };
  
    var transform = ctx.transform;
    ctx.transform = function(a,b,c,d,e,f){
        var m2 = svg.createSVGMatrix();
        m2.a=a; m2.b=b; m2.c=c; m2.d=d; m2.e=e; m2.f=f;
        xform = xform.multiply(m2);
        return transform.call(ctx,a,b,c,d,e,f);
    };
  
    var setTransform = ctx.setTransform;
    ctx.setTransform = function(a,b,c,d,e,f){
        xform.a = a;
        xform.b = b;
        xform.c = c;
        xform.d = d;
        xform.e = e;
        xform.f = f;
        return setTransform.call(ctx,a,b,c,d,e,f);
    };
  
    var pt  = svg.createSVGPoint();
    ctx.transformedPoint = function(x,y){
        pt.x=x; pt.y=y;
        return pt.matrixTransform(xform.inverse());
    }
  }
     var isPointInPoly = function(points, pt){
	
		var poly = [];
		for (var i = 0; i < points.length; i+=2) {
			poly.push({x: points[i], y: points[i+1]});
		}
		
		for(var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)
			((poly[i].y <= pt.y && pt.y < poly[j].y) || (poly[j].y <= pt.y && pt.y < poly[i].y))
			&& (pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)
			&& (c = !c);
		return c;
	};
console.log("teste") 
// function changeName(e){
//     console.log(e)
    
// }